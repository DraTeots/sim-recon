
//
//
// This macro is used to generate ASCII files containing a parameterized 
// magnetic field map in a format suitable for use with the JANA
// JCalibrationFile class. It takes as input the root files 
// BfieldParameters_Bz.root and BfieldParameters_Bx.root which themselves
// are produced by the ParameterizeBField.C macro using bfield.root
// file as input. (The bfield.root file is generated with the bfield2root
// utility from a full map already in the calibDB).
//

//------------------------------
// ParameterizeBField_codegen
//------------------------------
void ParameterizeBField_codegen(const char *based_on="_1500_poisson_20090814_01")
{
	gROOT->Reset();

	WriteFile("BfieldParameters_Bz.root", "Bz", based_on);
	WriteFile("BfieldParameters_Bx.root", "Bx", based_on);
}

//------------------------------
// WriteFile
//------------------------------
void WriteFile(const char *input_fname, string element,const char *based_on)
{
#define MAX_SECTIONS 100

	TFile *f = new TFile(input_fname);
	
	cout<<"------------------- Ignore errors in this section --------------------"<<endl;

	// Get min and max for each section as well as number of sections
	double zmin[MAX_SECTIONS], zmax[MAX_SECTIONS];
	UInt_t Nsec;
	for(Nsec=0; Nsec<MAX_SECTIONS; Nsec++){
		stringstream hname;
		hname<<"sec"<<(Nsec+1)<<"_p0";	// sec1_p0, sec2_p0, ...
		TH1D *sec_p0 = (TH1D*)gROOT->FindObject(hname.str().c_str());
		if(!sec_p0)break;
		zmin[Nsec] = sec_p0->GetXaxis()->GetXmin();
		zmax[Nsec] = sec_p0->GetXaxis()->GetXmax();
	}

	// Get order of Chebyshev polynomials used for 1st level of parameterization
	UInt_t order1;
	for(order1=0; order1<20; order1++){
		stringstream hname;
		hname<<"sec1"<<"_p"<<order1;
		TH1D *sec1_p = (TH1D*)gROOT->FindObject(hname.str().c_str());
		if(!sec1_p){order1--; break;}
	}

	// Get order of Chebyshev polynomials used for 2nd level of parameterization
	TH1D *sec1_pp0 = (TH1D*)gROOT->FindObject("sec1_pp0");
	UInt_t order2 = sec1_pp0->GetNbinsX()-1;

	cout<<"----------------------------------------------------------------------"<<endl;

	// Information messages
	cout<<endl;
	cout<<"Writing parameters for:"<<endl;
	cout<<"       sections = "<<Nsec<<endl;
	cout<<"1st level order = "<<order1<<endl;
	cout<<"2nd level order = "<<order2<<endl;
	cout<<endl;

	// Parameters
	for(UInt_t sec=1; sec<=Nsec; sec++){
		
		// Open output file
		stringstream fname;
		fname<<"solenoid"<<based_on<<"_"<<element<<"_chebyshev_sec"<<sec;
		ofstream fout(fname.str().c_str());
		cout<<"Writing parameters to "<<fname.str()<<endl;
		
		// Write header info to file
		time_t now = time(NULL);
		fout<<"#"<<endl;
		fout<<"# Solenoidal field parameterization"<<endl;
		fout<<"#"<<endl;
		fout<<"# This file auto-generated by ParameterizeBField_codegen.C macro."<<endl;
		fout<<"# "<<ctime(&now);
		fout<<"# Produced by "<<getenv("USER")<<" on "<<getenv("HOST")<<endl;
		fout<<"#"<<endl;
		fout<<"#      input file: "<<f->GetName()<<endl;
		fout<<"#         section: "<<sec<<"  (out of "<<Nsec<<")"<<endl;
		fout<<"# 1st level order: "<<order1<<endl;
		fout<<"# 2nd level order: "<<order2<<endl;
		fout<<"#"<<endl;		
		fout<<"# In the following table, values are coefficients of Chebyshev"<<endl;		
		fout<<"# polynomials. There are 2 levels of parameterization corresponding"<<endl;		
		fout<<"# to the 2 dimensions in which the field map is parameterized (z and r)."<<endl;		
		fout<<"#"<<endl;
		fout<<"# The first level fits the field as a function of z in lab coordinates."<<endl;
		fout<<"# The second level parametrizes those coefficients as a function of r"<<endl;
		fout<<"# also in lab coordinates."<<endl;
		fout<<"#"<<endl;
		fout<<"#"<<endl;
		fout<<"#"<<endl;

		int chars_per_val = 14;
		string header((order2+1)*chars_per_val, ' ');
		for(UInt_t j=0; j<=order2; j++){
			stringstream name;
			name<<"p"<<j;
			string &s = name.str();
			header.replace((j+1)*chars_per_val-s.length()-2, s.length(), s);
		}
		fout<<"#"<<header<<endl;

		// Loop
		for(UInt_t i=0; i<=order1; i++){
			stringstream hname;
			hname<<"sec"<<sec<<"_pp"<<i;
			TH1D *h = (TH1D*)gROOT->FindObject(hname.str().c_str());
			
			string line((order2+1)*chars_per_val, ' ');
			for(UInt_t j=0; j<=order2; j++){
				stringstream val;
				val<<h->GetBinContent(j);
				string &s = val.str();
				if(s.length()>=chars_per_val){
					cerr<<"ERROR: too many characters in val! ("<<__FILE__<<":"<<__LINE__<<")"<<endl;
					return -1;
				}
				line.replace((j+1)*chars_per_val-s.length(), s.length(), s);
			}
			fout<<line<<endl;
		}
		
		fout.close();
	}
}


